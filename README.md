# StaticGenie

The framework to intuitively create static websites. Built primarily for JavaScript developers using TypeScript and focusing on 2 core areas; Simplicity & Community

# Installation

You will require;

- Docker
- Git

Simple right?

Clone this repo and run `docker-compose run sg npm install`. You should then be all setup and ready to go.

# Running Commands Inside Docker

Since everything is dockerised. All commands should be run through `docker-compose`. Remember to run these within the projects working directory. i.e. `cd cloned-staticgenie-repo`.

To run a command;

`docker-compose run --service-ports sg command-goes-here`

## Common Commands

- `docker-compose run sg npm install --save {package-name}` - Install a new package
- `docker-compose run sg npm install --save @types/{package-name}` - Save new typescript types
- `docker-compose run --service-ports sg npm run` - Complete a build from start to finish & make available at http://127.0.0.1:8080/

_Note: Without `--service-ports` you will not be able to connect the http server started by the `node run server` command or any commands that use it_

## NPM Commands

When you wish to run StaticGenie. Use the following command: `docker-compose run sg npm run {commands-below}`. There are various built in commands;

- `build:fresh` - Removes anything generated from the previous run. Ensures everything is clean and no previous artifacts left behind
- `build:typescript` - Converts the typescript to javascript. Gives you quicker feedback than having to generate the website everytime you wish to test
- `build:pages` - Build your web pages
- `build:assets` - Copies over any supporting assets .css, .js, .jpg etc from `/theme/assets` to the `/www/assets` directory
- `build:clean` - Cleans up any temporary artifacts such as compiled typescript ready for the next build
- `build:optimise` - @TODO - Will perform optimisations like CSS/JS minification, etc
- `server` - Creates a server that serves your ./www directory (generated by StaticGenie)
- `test` - @TODO - Compile and tests the javascript (although this isn't working yet)
- `start` - runs all the build scripts in order (start here)

You can open up `/package.json` to see/modify the commands or run `docker-compose run sg npm run` to see the commands npm has loaded from the `/package.json` file.

# Directory Structure

- `/data/{plugin}` - Data used by the respective plugin.
- `/src` - The StaticGenie source code (best to stay out of here unless you know what you're doing or you're creating a service/plugin).
- `/theme/assets` - Any assets such as .css, .zip, .png, .js etc you want to add to your site. Accessible from the theme layouts via `/assets/*`
- `/theme/layouts` - In order to create any page with a unique look and feel (such as /contact.html with a contact form) it needs a layout. They are defined here.
- `/theme/partials` - When you want a portion of html to be to shared across multiple layouts (e.g. header & footer)
- `/www` - Your generated website! Copy all the contents of this folder to your web host.
- `/config.ts` - General configuration of your website.
- `/docs` - Documentation (although you will also be able to see this at https://staticgenie.com)












# Build A Website

@TODO write this section

- Creating 3 new pages using the pages plugin
- Creating a new layout using the pages plugin
- Displaying an image using the pages plugin
- Converting common HTML to a layout/partial using the pages plugin (moves properties to the page.* model that other pages can also use)

Models: Global (frozen after all plugins initialised), Theme (from config.ts, instantly frozen), Page (always mutable)

# Core Service Providers

@TODO write this section

- globalmodel
- pagewriter
- report
- theme

# Core Plugins

@TODO write this section

- pages (see Build A Website section of this readme)

# Creating A Plugin

@TODO write this section

A plugin is responsible for generating web pages. They may uses various services to do this as well as it's configuration (defined within `/config.ts`). Plugins can not access other plugins.

**WARNING: It is possible to register new services from a plugin. DO NOT do this. In time this options will no longer be available.**















# Creating A Theme

- Place any supporting assets within `/theme/assets` such as .css, .jpg, and .js files
- Create your EJS layouts within `/theme/layouts`
- Create any shared includes/partials used by the layouts within `/theme/partials`
- Update `/theme/package.ts` with an exported interface called `iThemeConfigData`. Define all the config data used directly by your theme.

When building a theme, you can access model data within your templates using the following keys:

- `theme.{key}` - the defined values within `config.ts` relating to the `theme` service provider
- `page.{key}` - any page specific values defined by plugins when generating the specific page
- `global.{key}` - global model generated when all plugins initialise, stored within the `globalmodel` service provider

# Creating A Service

## What is a Service provider

A service provides capabilities mostly for plugins to use. Services are instantiated once by the framework and that same instance shared across all plugins. Services are access via interfaces to allow them to be switched out for different implementations.

## Example service providers

- `pagewriter` - responsible for writing "pages" (such as web pages) to the disk, console, etc
- `report` - responsible for generating a report on how the website generation went (i.e. did all the pages get generated ok)
- `theme` - responsible for rendering a template into pages
- `globalmodel` - responsible for storing the global model populated by the initialisation method of plugins

## Service structure

**WARNING: Services are capable of using other services, however, other services should NOT be used during initialisation else it will create a dependency on the order in which the services are initialised. They can however safely be stored within the object for later use.**

Here is a template for a new service. Replace `[SERVICENAME]` with the name of your service. Then save the file within ./src/libs/services/*.ts

```
import {iConfigService, iService, Services} from "../libs/services"

/**
* Allows you to provide multiple implementations of your service. This should be used when getting an instance of this service.
*/
export interface i[SERVICENAME] {
    
}

/**
* You don't have to export this, you can make it abstract but make sure you export one or more of it sub classes
*/
export class [SERVICENAME] implements iService, i[SERVICENAME] {

    /**
     * Initialise using provided config
     * @param services 
     * @param config
     */
    initialise(services:Services, config:i[SERVICENAME]Config) {
        
    }

    /**
     * Called when all plugins have initialised
     */
    pluginsInitialised() {

    }

    /**
     * Called when all plugins have generated their respective pages
     */
    pluginsGenerated() {

    }

}

/**
* Defines the configuration (if any) that can be configured within `/config.ts`
*/
export interface i[SERVICENAME]Config extends iConfigService {

}
```

## Registering & configuring the service

Open `/config.ts`. 

Locate the services sections. Within you will see two more sections `beforePluginsInitialised` and `afterPluginsInitialised`. You need to register your plugin and it's configuration in the relevant section.

- `beforePluginsInitialised` - If you want the plugins to be able to access your service during the initialisation stage (such as when building the shared global model) and during the plugins generator method then register it here. Most services won't need to be registered here.
- `afterPluginsInitialised` - Once all plugins have been initiated, your service becomes available to use within each plugins generator method.

A service config looks like this.

```
"../services/globalmodel": { 
    
    // The name used to get an instance of the service. DO NOT change this else any 3rd party dependencies will break. 
    name: "[SERVICENAME]", 
    
    // The class to create an instance of (you can switch this out since the service should be developed against the interface defined within the file)
    class: [CLASSNAME].name,
    
    // The config interface used to help define the correct format of the config followed by the actual configuration of the service
    config: <i[CLASSNAME]Config>{}

},
```

An example of a completed service registered within the `beforePluginsInitialised` section.

```
services: {
    beforePluginsInitialised: {
        "../services/globalmodel": { 
            name: "globalmodel", 
            class: GlobalModel.name,
            config: <iGlobalModelConfig>{}
        },
    },
    afterPluginsInitialised: {
        
    },
}
```

If installed (and classes/interfaces imported) correctly, you should be able to call the service within plugin methods and service methods like: `services.get("[NAME]").[METHOD]()`

# Tips

- `@TODO` is a convention I have used to tag anything that needs looking into. Using VSCode I open a global search panel with `@TODO` and it provides me a todo list. I then check each of the todos before a release and use the todos to ensure refactorings and similar tech debt do not get forgotten.
- When using a service provider, it's a good idea to hint the interface i.e. `let global = <iGlobalModel>services.get("globalmodel")` which will allow TypeScript static checking to work as well as your IDE intellisense.